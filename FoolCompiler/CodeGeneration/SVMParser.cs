//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from SVM.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419


using FoolCompiler.CodeGeneration;
using System.Collections.Generic;

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
[System.CLSCompliant(false)]
public partial class SVMParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		PUSH=1, POP=2, ADD=3, SUB=4, MULT=5, DIV=6, STOREW=7, LOADW=8, BRANCH=9, 
		BRANCHEQ=10, BRANCHLESSEQ=11, JS=12, LOADRA=13, STORERA=14, LOADRV=15, 
		STORERV=16, LOADFP=17, STOREFP=18, COPYFP=19, LOADHP=20, STOREHP=21, PRINT=22, 
		HALT=23, NEW=24, LOADMETHOD=25, COPYTOPSTACK=26, COL=27, LABEL=28, NUMBER=29, 
		WHITESP=30, ERR=31;
	public const int
		RULE_assembly = 0;
	public static readonly string[] ruleNames = {
		"assembly"
	};

	private static readonly string[] _LiteralNames = {
		null, "'push'", "'pop'", "'add'", "'sub'", "'mult'", "'div'", "'sw'", 
		"'lw'", "'b'", "'beq'", "'bleq'", "'js'", "'lra'", "'sra'", "'lrv'", "'srv'", 
		"'lfp'", "'sfp'", "'cfp'", "'lhp'", "'shp'", "'print'", "'halt'", "'new'", 
		"'loadm'", "'cts'", "':'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "PUSH", "POP", "ADD", "SUB", "MULT", "DIV", "STOREW", "LOADW", "BRANCH", 
		"BRANCHEQ", "BRANCHLESSEQ", "JS", "LOADRA", "STORERA", "LOADRV", "STORERV", 
		"LOADFP", "STOREFP", "COPYFP", "LOADHP", "STOREHP", "PRINT", "HALT", "NEW", 
		"LOADMETHOD", "COPYTOPSTACK", "COL", "LABEL", "NUMBER", "WHITESP", "ERR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "SVM.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static SVMParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

    public int GetNumberOfSyntaxErrors()
    {
        return NumberOfSyntaxErrors;
    }


    private List<int> _code = new List<int>();

	    private Dictionary<string,int> _labelAdd = new Dictionary<string,int>();
	    private Dictionary<int,string> _labelRef = new  Dictionary<int,string>();


	    public List<int> GetCode() {return _code;}

		public SVMParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public SVMParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class AssemblyContext : ParserRuleContext {
		public IToken n;
		public IToken l;
		public ITerminalNode[] PUSH() { return GetTokens(SVMParser.PUSH); }
		public ITerminalNode PUSH(int i) {
			return GetToken(SVMParser.PUSH, i);
		}
		public ITerminalNode[] POP() { return GetTokens(SVMParser.POP); }
		public ITerminalNode POP(int i) {
			return GetToken(SVMParser.POP, i);
		}
		public ITerminalNode[] ADD() { return GetTokens(SVMParser.ADD); }
		public ITerminalNode ADD(int i) {
			return GetToken(SVMParser.ADD, i);
		}
		public ITerminalNode[] SUB() { return GetTokens(SVMParser.SUB); }
		public ITerminalNode SUB(int i) {
			return GetToken(SVMParser.SUB, i);
		}
		public ITerminalNode[] MULT() { return GetTokens(SVMParser.MULT); }
		public ITerminalNode MULT(int i) {
			return GetToken(SVMParser.MULT, i);
		}
		public ITerminalNode[] DIV() { return GetTokens(SVMParser.DIV); }
		public ITerminalNode DIV(int i) {
			return GetToken(SVMParser.DIV, i);
		}
		public ITerminalNode[] STOREW() { return GetTokens(SVMParser.STOREW); }
		public ITerminalNode STOREW(int i) {
			return GetToken(SVMParser.STOREW, i);
		}
		public ITerminalNode[] LOADW() { return GetTokens(SVMParser.LOADW); }
		public ITerminalNode LOADW(int i) {
			return GetToken(SVMParser.LOADW, i);
		}
		public ITerminalNode[] COL() { return GetTokens(SVMParser.COL); }
		public ITerminalNode COL(int i) {
			return GetToken(SVMParser.COL, i);
		}
		public ITerminalNode[] BRANCH() { return GetTokens(SVMParser.BRANCH); }
		public ITerminalNode BRANCH(int i) {
			return GetToken(SVMParser.BRANCH, i);
		}
		public ITerminalNode[] BRANCHEQ() { return GetTokens(SVMParser.BRANCHEQ); }
		public ITerminalNode BRANCHEQ(int i) {
			return GetToken(SVMParser.BRANCHEQ, i);
		}
		public ITerminalNode[] BRANCHLESSEQ() { return GetTokens(SVMParser.BRANCHLESSEQ); }
		public ITerminalNode BRANCHLESSEQ(int i) {
			return GetToken(SVMParser.BRANCHLESSEQ, i);
		}
		public ITerminalNode[] JS() { return GetTokens(SVMParser.JS); }
		public ITerminalNode JS(int i) {
			return GetToken(SVMParser.JS, i);
		}
		public ITerminalNode[] LOADRA() { return GetTokens(SVMParser.LOADRA); }
		public ITerminalNode LOADRA(int i) {
			return GetToken(SVMParser.LOADRA, i);
		}
		public ITerminalNode[] STORERA() { return GetTokens(SVMParser.STORERA); }
		public ITerminalNode STORERA(int i) {
			return GetToken(SVMParser.STORERA, i);
		}
		public ITerminalNode[] LOADRV() { return GetTokens(SVMParser.LOADRV); }
		public ITerminalNode LOADRV(int i) {
			return GetToken(SVMParser.LOADRV, i);
		}
		public ITerminalNode[] STORERV() { return GetTokens(SVMParser.STORERV); }
		public ITerminalNode STORERV(int i) {
			return GetToken(SVMParser.STORERV, i);
		}
		public ITerminalNode[] LOADFP() { return GetTokens(SVMParser.LOADFP); }
		public ITerminalNode LOADFP(int i) {
			return GetToken(SVMParser.LOADFP, i);
		}
		public ITerminalNode[] STOREFP() { return GetTokens(SVMParser.STOREFP); }
		public ITerminalNode STOREFP(int i) {
			return GetToken(SVMParser.STOREFP, i);
		}
		public ITerminalNode[] COPYFP() { return GetTokens(SVMParser.COPYFP); }
		public ITerminalNode COPYFP(int i) {
			return GetToken(SVMParser.COPYFP, i);
		}
		public ITerminalNode[] LOADHP() { return GetTokens(SVMParser.LOADHP); }
		public ITerminalNode LOADHP(int i) {
			return GetToken(SVMParser.LOADHP, i);
		}
		public ITerminalNode[] STOREHP() { return GetTokens(SVMParser.STOREHP); }
		public ITerminalNode STOREHP(int i) {
			return GetToken(SVMParser.STOREHP, i);
		}
		public ITerminalNode[] PRINT() { return GetTokens(SVMParser.PRINT); }
		public ITerminalNode PRINT(int i) {
			return GetToken(SVMParser.PRINT, i);
		}
		public ITerminalNode[] NEW() { return GetTokens(SVMParser.NEW); }
		public ITerminalNode NEW(int i) {
			return GetToken(SVMParser.NEW, i);
		}
		public ITerminalNode[] LOADMETHOD() { return GetTokens(SVMParser.LOADMETHOD); }
		public ITerminalNode LOADMETHOD(int i) {
			return GetToken(SVMParser.LOADMETHOD, i);
		}
		public ITerminalNode[] HALT() { return GetTokens(SVMParser.HALT); }
		public ITerminalNode HALT(int i) {
			return GetToken(SVMParser.HALT, i);
		}
		public ITerminalNode[] COPYTOPSTACK() { return GetTokens(SVMParser.COPYTOPSTACK); }
		public ITerminalNode COPYTOPSTACK(int i) {
			return GetToken(SVMParser.COPYTOPSTACK, i);
		}
		public ITerminalNode[] NUMBER() { return GetTokens(SVMParser.NUMBER); }
		public ITerminalNode NUMBER(int i) {
			return GetToken(SVMParser.NUMBER, i);
		}
		public ITerminalNode[] LABEL() { return GetTokens(SVMParser.LABEL); }
		public ITerminalNode LABEL(int i) {
			return GetToken(SVMParser.LABEL, i);
		}
		public AssemblyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assembly; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISVMListener typedListener = listener as ISVMListener;
			if (typedListener != null) typedListener.EnterAssembly(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISVMListener typedListener = listener as ISVMListener;
			if (typedListener != null) typedListener.ExitAssembly(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISVMVisitor<TResult> typedVisitor = visitor as ISVMVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssembly(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssemblyContext assembly() {
		AssemblyContext _localctx = new AssemblyContext(Context, State);
		EnterRule(_localctx, 0, RULE_assembly);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 68;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << PUSH) | (1L << POP) | (1L << ADD) | (1L << SUB) | (1L << MULT) | (1L << DIV) | (1L << STOREW) | (1L << LOADW) | (1L << BRANCH) | (1L << BRANCHEQ) | (1L << BRANCHLESSEQ) | (1L << JS) | (1L << LOADRA) | (1L << STORERA) | (1L << LOADRV) | (1L << STORERV) | (1L << LOADFP) | (1L << STOREFP) | (1L << COPYFP) | (1L << LOADHP) | (1L << STOREHP) | (1L << PRINT) | (1L << HALT) | (1L << NEW) | (1L << LOADMETHOD) | (1L << COPYTOPSTACK) | (1L << LABEL))) != 0)) {
				{
				State = 66;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
				case 1:
					{
					State = 2; Match(PUSH);
					State = 3; _localctx.n = Match(NUMBER);
					   _code.Add(PUSH);
								                            _code.Add(int.Parse((_localctx.n!=null?_localctx.n.Text:null)));     
					}
					break;
				case 2:
					{
					State = 5; Match(PUSH);
					State = 6; _localctx.l = Match(LABEL);
					   _code.Add(PUSH);
						    		                        _labelRef.Add(_code.Count, (_localctx.l!=null?_localctx.l.Text:null));
						    		                        _code.Add(0);                             
					}
					break;
				case 3:
					{
					State = 8; Match(POP);
					   _code.Add(POP);  
					}
					break;
				case 4:
					{
					State = 10; Match(ADD);
					   _code.Add(ADD);  
					}
					break;
				case 5:
					{
					State = 12; Match(SUB);
					   _code.Add(SUB);    
					}
					break;
				case 6:
					{
					State = 14; Match(MULT);
					   _code.Add(MULT);   
					}
					break;
				case 7:
					{
					State = 16; Match(DIV);
					   _code.Add(DIV);  
					}
					break;
				case 8:
					{
					State = 18; Match(STOREW);
					   _code.Add(STOREW);   
					}
					break;
				case 9:
					{
					State = 20; Match(LOADW);
					   _code.Add(LOADW);    
					}
					break;
				case 10:
					{
					State = 22; _localctx.l = Match(LABEL);
					State = 23; Match(COL);
					   _labelAdd.Add((_localctx.l!=null?_localctx.l.Text:null), _code.Count);   
					}
					break;
				case 11:
					{
					State = 25; Match(BRANCH);
					State = 26; _localctx.l = Match(LABEL);
					   _code.Add(BRANCH);
					                                        _labelRef.Add(_code.Count, (_localctx.l!=null?_localctx.l.Text:null));
					                                        _code.Add(0);                          
					}
					break;
				case 12:
					{
					State = 28; Match(BRANCHEQ);
					State = 29; _localctx.l = Match(LABEL);
						_code.Add(BRANCHEQ);
															_labelRef.Add(_code.Count, (_localctx.l!=null?_localctx.l.Text:null));
															_code.Add(0);  
					}
					break;
				case 13:
					{
					State = 31; Match(BRANCHLESSEQ);
					State = 32; _localctx.l = Match(LABEL);
						_code.Add(BRANCHLESSEQ);
															_labelRef.Add(_code.Count,(_localctx.l!=null?_localctx.l.Text:null));
															_code.Add(0); 
					}
					break;
				case 14:
					{
					State = 34; Match(JS);
					   _code.Add(JS);    
					}
					break;
				case 15:
					{
					State = 36; Match(LOADRA);
					   _code.Add(LOADRA);   
					}
					break;
				case 16:
					{
					State = 38; Match(STORERA);
					   _code.Add(STORERA);  
					}
					break;
				case 17:
					{
					State = 40; Match(LOADRV);
					   _code.Add(LOADRV);   
					}
					break;
				case 18:
					{
					State = 42; Match(STORERV);
					   _code.Add(STORERV);  
					}
					break;
				case 19:
					{
					State = 44; Match(LOADFP);
					   _code.Add(LOADFP);   
					}
					break;
				case 20:
					{
					State = 46; Match(STOREFP);
					   _code.Add(STOREFP);  
					}
					break;
				case 21:
					{
					State = 48; Match(COPYFP);
					   _code.Add(COPYFP);   
					}
					break;
				case 22:
					{
					State = 50; Match(LOADHP);
					   _code.Add(LOADHP);   
					}
					break;
				case 23:
					{
					State = 52; Match(STOREHP);
					   _code.Add(STOREHP);  
					}
					break;
				case 24:
					{
					State = 54; Match(PRINT);
					   _code.Add(PRINT);    
					}
					break;
				case 25:
					{
					State = 56; Match(NEW);
					   _code.Add(NEW);      
					}
					break;
				case 26:
					{
					State = 58; Match(LOADMETHOD);
					   _code.Add(LOADMETHOD);       
					}
					break;
				case 27:
					{
					State = 60; Match(HALT);
					   _code.Add(HALT);     
					}
					break;
				case 28:
					{
					State = 62; _localctx.l = Match(LABEL);
					   _labelRef.Add(_code.Count, (_localctx.l!=null?_localctx.l.Text:null));
						                                    _code.Add(0);        
					}
					break;
				case 29:
					{
					State = 64; Match(COPYTOPSTACK);
					   _code.Add(COPYTOPSTACK);     
					}
					break;
				}
				}
				State = 70;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}

				        foreach (int refAdd in _labelRef.Keys) {
				            _code[refAdd] =  _labelAdd[_labelRef[refAdd]];
				        }
				   
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '!', 'L', '\x4', '\x2', '\t', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x2', '\x3', '\x2', '\a', '\x2', '\x45', '\n', '\x2', '\f', 
		'\x2', '\xE', '\x2', 'H', '\v', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x2', '\x2', '\x3', '\x2', '\x2', '\x2', '\x2', 'g', '\x2', '\x46', 
		'\x3', '\x2', '\x2', '\x2', '\x4', '\x5', '\a', '\x3', '\x2', '\x2', '\x5', 
		'\x6', '\a', '\x1F', '\x2', '\x2', '\x6', '\x45', '\b', '\x2', '\x1', 
		'\x2', '\a', '\b', '\a', '\x3', '\x2', '\x2', '\b', '\t', '\a', '\x1E', 
		'\x2', '\x2', '\t', '\x45', '\b', '\x2', '\x1', '\x2', '\n', '\v', '\a', 
		'\x4', '\x2', '\x2', '\v', '\x45', '\b', '\x2', '\x1', '\x2', '\f', '\r', 
		'\a', '\x5', '\x2', '\x2', '\r', '\x45', '\b', '\x2', '\x1', '\x2', '\xE', 
		'\xF', '\a', '\x6', '\x2', '\x2', '\xF', '\x45', '\b', '\x2', '\x1', '\x2', 
		'\x10', '\x11', '\a', '\a', '\x2', '\x2', '\x11', '\x45', '\b', '\x2', 
		'\x1', '\x2', '\x12', '\x13', '\a', '\b', '\x2', '\x2', '\x13', '\x45', 
		'\b', '\x2', '\x1', '\x2', '\x14', '\x15', '\a', '\t', '\x2', '\x2', '\x15', 
		'\x45', '\b', '\x2', '\x1', '\x2', '\x16', '\x17', '\a', '\n', '\x2', 
		'\x2', '\x17', '\x45', '\b', '\x2', '\x1', '\x2', '\x18', '\x19', '\a', 
		'\x1E', '\x2', '\x2', '\x19', '\x1A', '\a', '\x1D', '\x2', '\x2', '\x1A', 
		'\x45', '\b', '\x2', '\x1', '\x2', '\x1B', '\x1C', '\a', '\v', '\x2', 
		'\x2', '\x1C', '\x1D', '\a', '\x1E', '\x2', '\x2', '\x1D', '\x45', '\b', 
		'\x2', '\x1', '\x2', '\x1E', '\x1F', '\a', '\f', '\x2', '\x2', '\x1F', 
		' ', '\a', '\x1E', '\x2', '\x2', ' ', '\x45', '\b', '\x2', '\x1', '\x2', 
		'!', '\"', '\a', '\r', '\x2', '\x2', '\"', '#', '\a', '\x1E', '\x2', '\x2', 
		'#', '\x45', '\b', '\x2', '\x1', '\x2', '$', '%', '\a', '\xE', '\x2', 
		'\x2', '%', '\x45', '\b', '\x2', '\x1', '\x2', '&', '\'', '\a', '\xF', 
		'\x2', '\x2', '\'', '\x45', '\b', '\x2', '\x1', '\x2', '(', ')', '\a', 
		'\x10', '\x2', '\x2', ')', '\x45', '\b', '\x2', '\x1', '\x2', '*', '+', 
		'\a', '\x11', '\x2', '\x2', '+', '\x45', '\b', '\x2', '\x1', '\x2', ',', 
		'-', '\a', '\x12', '\x2', '\x2', '-', '\x45', '\b', '\x2', '\x1', '\x2', 
		'.', '/', '\a', '\x13', '\x2', '\x2', '/', '\x45', '\b', '\x2', '\x1', 
		'\x2', '\x30', '\x31', '\a', '\x14', '\x2', '\x2', '\x31', '\x45', '\b', 
		'\x2', '\x1', '\x2', '\x32', '\x33', '\a', '\x15', '\x2', '\x2', '\x33', 
		'\x45', '\b', '\x2', '\x1', '\x2', '\x34', '\x35', '\a', '\x16', '\x2', 
		'\x2', '\x35', '\x45', '\b', '\x2', '\x1', '\x2', '\x36', '\x37', '\a', 
		'\x17', '\x2', '\x2', '\x37', '\x45', '\b', '\x2', '\x1', '\x2', '\x38', 
		'\x39', '\a', '\x18', '\x2', '\x2', '\x39', '\x45', '\b', '\x2', '\x1', 
		'\x2', ':', ';', '\a', '\x1A', '\x2', '\x2', ';', '\x45', '\b', '\x2', 
		'\x1', '\x2', '<', '=', '\a', '\x1B', '\x2', '\x2', '=', '\x45', '\b', 
		'\x2', '\x1', '\x2', '>', '?', '\a', '\x19', '\x2', '\x2', '?', '\x45', 
		'\b', '\x2', '\x1', '\x2', '@', '\x41', '\a', '\x1E', '\x2', '\x2', '\x41', 
		'\x45', '\b', '\x2', '\x1', '\x2', '\x42', '\x43', '\a', '\x1C', '\x2', 
		'\x2', '\x43', '\x45', '\b', '\x2', '\x1', '\x2', '\x44', '\x4', '\x3', 
		'\x2', '\x2', '\x2', '\x44', '\a', '\x3', '\x2', '\x2', '\x2', '\x44', 
		'\n', '\x3', '\x2', '\x2', '\x2', '\x44', '\f', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '\xE', '\x3', '\x2', '\x2', '\x2', '\x44', '\x10', '\x3', '\x2', 
		'\x2', '\x2', '\x44', '\x12', '\x3', '\x2', '\x2', '\x2', '\x44', '\x14', 
		'\x3', '\x2', '\x2', '\x2', '\x44', '\x16', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '\x18', '\x3', '\x2', '\x2', '\x2', '\x44', '\x1B', '\x3', '\x2', 
		'\x2', '\x2', '\x44', '\x1E', '\x3', '\x2', '\x2', '\x2', '\x44', '!', 
		'\x3', '\x2', '\x2', '\x2', '\x44', '$', '\x3', '\x2', '\x2', '\x2', '\x44', 
		'&', '\x3', '\x2', '\x2', '\x2', '\x44', '(', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '*', '\x3', '\x2', '\x2', '\x2', '\x44', ',', '\x3', '\x2', '\x2', 
		'\x2', '\x44', '.', '\x3', '\x2', '\x2', '\x2', '\x44', '\x30', '\x3', 
		'\x2', '\x2', '\x2', '\x44', '\x32', '\x3', '\x2', '\x2', '\x2', '\x44', 
		'\x34', '\x3', '\x2', '\x2', '\x2', '\x44', '\x36', '\x3', '\x2', '\x2', 
		'\x2', '\x44', '\x38', '\x3', '\x2', '\x2', '\x2', '\x44', ':', '\x3', 
		'\x2', '\x2', '\x2', '\x44', '<', '\x3', '\x2', '\x2', '\x2', '\x44', 
		'>', '\x3', '\x2', '\x2', '\x2', '\x44', '@', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '\x42', '\x3', '\x2', '\x2', '\x2', '\x45', 'H', '\x3', '\x2', 
		'\x2', '\x2', '\x46', '\x44', '\x3', '\x2', '\x2', '\x2', '\x46', 'G', 
		'\x3', '\x2', '\x2', '\x2', 'G', 'I', '\x3', '\x2', '\x2', '\x2', 'H', 
		'\x46', '\x3', '\x2', '\x2', '\x2', 'I', 'J', '\b', '\x2', '\x1', '\x2', 
		'J', '\x3', '\x3', '\x2', '\x2', '\x2', '\x4', '\x44', '\x46',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
